/* ########
 * 2023 MikroKit
 * Author: Ma-jerez
 * License: MIT
 * The software is provided "as is", without warranty of any kind.
 * ######## */

import {PublicRoutes, isPublicRoutes} from '@mikrokit/router';
import {parse} from 'path';
import type {CodegenOptions} from './types';
// @ypes/cross-spawn is not updated,, once it gets updated we could use normal es6 import
import spawn = require('cross-spawn');

const TYPE_WRAPPER = '##@@==>MiKrOKIt==RoUte==TyPE<==@@##';

/** Resturns the TS Spec Source Code */
export const getSpecFile = (options: CodegenOptions, routesList: PublicRoutes<any>[], exportNames: string[]) => {
    const parsedRoutesList = setHandlerTypes(routesList, exportNames);
    const entryTsName = parse(options.entryFileName).name;
    const serializeRoutes = (route: PublicRoutes<any>, exportName: string) =>
        ` export const ${exportName}Procedures = ${JSON.stringify(route, null, 2)};`;
    const specFile =
        `/* ######## THIS CODE IS AUTOMATICALLY GENERATED BY MIKROKIT ROUTER, DO NOT MDIFY ######## */\n` +
        `import type {${exportNames.join(', ')}} from './${entryTsName}'\n` +
        `function fakeHandlerError(){ throw new Error('handlers can not be called directly!');}\n` +
        exportNames.map((name, i) => serializeRoutes(parsedRoutesList[i], name)).join('\n');
    return specFile.replaceAll(`"${TYPE_WRAPPER}`, '').replaceAll(`${TYPE_WRAPPER}"`, '');
};

const setHandlerTypes = (routesList: PublicRoutes<any>[], exportNames: string[]): PublicRoutes<any>[] => {
    return exportNames.map((name, i) => recursiveSetHandlerType(routesList[i], name));
};

const recursiveSetHandlerType = (routes: PublicRoutes<any>, exportName: string): PublicRoutes<any> => {
    const newRoutes: PublicRoutes<any> = {};
    for (const key in routes) {
        const item = routes[key];
        if (!isPublicRoutes(item)) {
            if (item.canReturnData || item.params.length) {
                newRoutes[key] = {
                    ...item,
                    handlerType:
                        `${TYPE_WRAPPER}fakeHandlerError as any as typeof ${exportName}.${item.handlerType}.handlerType${TYPE_WRAPPER}` as any,
                };
            }
        } else {
            newRoutes[key] = recursiveSetHandlerType(item, exportName);
        }
    }
    return newRoutes;
};

/** Runs a js program in node */
export const runChildNode = (jsCode: string, cwd: string) => {
    spawn.sync('node', ['-e', jsCode], {cwd, stdio: 'inherit'});
};
