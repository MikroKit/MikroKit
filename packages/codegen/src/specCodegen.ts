/* ########
 * 2023 MikroKit
 * Author: Ma-jerez
 * License: MIT
 * The software is provided "as is", without warranty of any kind.
 * ######## */

import {PublicMethods, isPublicRoutes, PublicRoute, Obj, isPuplicMethod} from '@mikrokit/router';
import {dirname, parse, relative} from 'path';
import type {CodegenOptions, PublicMethodsSpec, RoutesSpec} from './types';
import {DEFAULT_PRETTIER_OPTIONS, PUBLIC_METHODS_SPEC_EXPORT_NAME, ROUTES_SPEC_EXPORT_NAME} from './constants';
import {format, Options as PrettierOptions} from 'prettier';
// @ypes/cross-spawn is not updated,, once it gets updated we could use normal es6 import
import spawn = require('cross-spawn');

/** Resturns the TS Spec Source Code */
export const getSpecFile = (options: CodegenOptions, routesList: PublicMethods<any>[], exportNames: string[]) => {
    const {publicMethods, routes} = getPublicMethodsAndRoutes(routesList, exportNames);
    const relativeImport = getRelativeImport(options.entryFileName, options.outputFileName);
    const specFileHeader =
        `/* ######## THIS CODE IS AUTOMATICALLY GENERATED BY MIKROKIT ROUTER, DO NOT MDIFY ######## */\n` +
        `/* ######## Generated at: ${new Date().toUTCString()} ######## */\n` +
        `\nimport type {${exportNames.join(', ')}} from '${relativeImport}'\n` +
        `function fakeHandler(){throw new Error('handlers can not be called directly from the spec file!')}\n`;
    const specFileContent = jsonStringsToCode(`${serializePublicMethods(publicMethods)}\n` + `${serializeRoutes(routes)}\n`);
    return specFileHeader + specFileContent;
};

export const getRelativeImport = (entryFileName: string, outputFileName: string) => {
    const entryTsName = parse(entryFileName).name;
    const relativePath = './' + relative(dirname(outputFileName), dirname(entryFileName));
    const relativeimport = relativePath.endsWith('/') ? `${relativePath}${entryTsName}` : `${relativePath}/${entryTsName}`;
    return relativeimport;
};

const getPublicMethodsAndRoutes = (routesList: PublicMethods<any>[], exportNames: string[]) => {
    const publicMethods: PublicMethodsSpec = {};
    const routes: RoutesSpec = {};
    exportNames.forEach((name, i) => {
        const routeSpec = {};
        const publicMethodsSpec = recursiveSetHandlerTypeAndCreateRouteExecutables(routesList[i], name, [], routeSpec);
        publicMethods[name] = publicMethodsSpec;
        routes[name] = routeSpec;
    });
    return {publicMethods, routes};
};

const recursiveSetHandlerTypeAndCreateRouteExecutables = (
    methods: PublicMethods<any>,
    exportName: string,
    currentPointer: string[],
    routeExecutables: Obj
): PublicMethods<any> => {
    const newRoutes: PublicMethods<any> = {};
    Object.entries(methods).forEach(([key, item]) => {
        const newPointer = [...currentPointer, key];
        if (isPublicRoutes(item)) {
            newRoutes[key] = recursiveSetHandlerTypeAndCreateRouteExecutables(item, exportName, newPointer, routeExecutables);
        } else if (isPuplicMethod(item)) {
            if (item.isRoute) {
                setRouteExecutables(item, newPointer, exportName, routeExecutables);
                delete item.publicExecutionPathPointers;
            }
            newRoutes[key] = {
                ...item,
                //this is a string
                handlerType: setCodeAsJsonString(
                    `fakeHandler as any as typeof ${exportName}.${item.handlerType}.handlerType`
                ) as any,
            };
        }
    });
    return newRoutes;
};

const serializePublicMethods = (publicMethods: PublicMethodsSpec) =>
    `\n// public methods specification (hooks and routes)\n` +
    ` export const ${PUBLIC_METHODS_SPEC_EXPORT_NAME} = ${JSON.stringify(publicMethods, null, 2)};`;

const serializeRoutes = (routes: RoutesSpec) =>
    `\n// routes specification, each route is a list of public methods that gets executed in order\n` +
    ` export const ${ROUTES_SPEC_EXPORT_NAME} = ${JSON.stringify(routes, null, 2)};`;

const setRouteExecutables = (route: PublicRoute<any>, currentPointer: string[], exportName: string, routeExecutables: Obj) => {
    const MethodPointers = route.publicExecutionPathPointers?.map((pointer) =>
        setCodeAsJsonString(`${PUBLIC_METHODS_SPEC_EXPORT_NAME}.${exportName}.${pointer.join('.')}`)
    );
    assignProperty(routeExecutables, currentPointer, MethodPointers);
};

const assignProperty = (obj: Obj, pointer: string[], value: any) => {
    let current = obj;
    pointer.forEach((key, i) => {
        if (i === pointer.length - 1) {
            current[key] = value;
        } else if (!current[key]) {
            current[key] = {};
        }
        current = current[key];
    });
};

// This does not support src code containing scaped double quotes, multiple lines etc, very simple statements only;
const codeWrapper = '##@@==>ThIs==IS==SourCe==CoDE<==@@##';
const setCodeAsJsonString = (code: string) => `${codeWrapper}${code}${codeWrapper}`;
const jsonStringsToCode = (srcFile: string) => srcFile.replaceAll(`"${codeWrapper}`, '').replaceAll(`${codeWrapper}"`, '');

/** Runs a js program in node */
export const runChildNode = (jsCode: string, cwd: string) => {
    spawn.sync('node', ['-e', jsCode], {cwd, stdio: 'inherit'});
};

/**
 * Formats src code using prettier
 * @param srcCode
 * @param opts
 * @returns
 */
export const formatCode = (srcCode: string, opts?: PrettierOptions) => {
    const prettierOpts = {
        ...DEFAULT_PRETTIER_OPTIONS,
        ...opts,
    };
    return format(srcCode, prettierOpts);
};
