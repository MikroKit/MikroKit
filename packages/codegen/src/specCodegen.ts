/* ########
 * 2023 MikroKit
 * Author: Ma-jerez
 * License: MIT
 * The software is provided "as is", without warranty of any kind.
 * ######## */

import {PublicMethods, isPublicRoutes, ROUTE_DEFAULT_PARAM} from '@mikrokit/router';
import {parse} from 'path';
import type {CodegenOptions} from './types';
// @ypes/cross-spawn is not updated,, once it gets updated we could use normal es6 import
const spawn = require('cross-spawn'); // eslint-disable-line @typescript-eslint/no-var-requires

/** Resturns the TS Spec Source Code */
export const getSpecFile = (options: CodegenOptions, routesList: PublicMethods<any>[], exportNames: string[]) => {
    const parsedRoutesList = setHandlerTypes(routesList, exportNames);
    const entryTsName = parse(options.entryFileName).name;
    const serializeRoutes = (route: PublicMethods<any>, exportName: string) =>
        ` export const ${exportName}PublicMethods = ${JSON.stringify(route, null, 2)};`;
    const specFile =
        `/* ######## THIS CODE IS AUTOMATICALLY GENERATED BY MIKROKIT ROUTER, DO NOT MDIFY ######## */\n` +
        `import type {${exportNames.join(', ')}} from './${entryTsName}'\n` +
        `function fakeHandlerError(){ throw new Error('handlers can not be called directly!');}\n` +
        exportNames.map((name, i) => serializeRoutes(parsedRoutesList[i], name)).join('\n');
    return jsonStringsToCode(specFile);
};

const setHandlerTypes = (routesList: PublicMethods<any>[], exportNames: string[]): PublicMethods<any>[] => {
    return exportNames.map((name, i) => recursiveSetHandlerType(routesList[i], name));
};

const recursiveSetHandlerType = (routes: PublicMethods<any>, exportName: string): PublicMethods<any> => {
    const newRoutes: PublicMethods<any> = {};
    Object.entries(routes).forEach(([key, item]) => {
        if (isPublicRoutes(item)) {
            newRoutes[key] = recursiveSetHandlerType(item, exportName);
        } else if (item.canReturnData || item.params.length) {
            newRoutes[key] = {
                ...item,
                //this is a string
                handlerType: setCodeAsJsonString(
                    `fakeHandlerError as any as typeof ${exportName}.${item.handlerType}.handlerType`
                ) as any,
            };
        }
    });
    return newRoutes;
};

// This does not support src code containing scaped double quotes, multiple lines etc, very simple statements only;
const codeWrapper = '##@@==>ThIs==IS==SourCe==CoDE<==@@##';
const setCodeAsJsonString = (code: string) => `${codeWrapper}${code}${codeWrapper}`;
const jsonStringsToCode = (srcFile: string) => srcFile.replaceAll(`"${codeWrapper}`, '').replaceAll(`${codeWrapper}"`, '');

/** Runs a js program in node */
export const runChildNode = (jsCode: string, cwd: string) => {
    spawn.sync('node', ['-e', jsCode], {cwd, stdio: 'inherit'});
};
