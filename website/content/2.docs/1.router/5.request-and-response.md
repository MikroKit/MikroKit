---
title: Request & Response
---

# Request & Response

The [MionRequest](#request) and [MionResponse](#response) objects available to every hook/route within the [`CallContext`](./3.call-context.md) (first parameter of every hook/route).

mion's request  and response are different from the underlying native http request and response, so mion can be used seamlessly in different environments.

**Example:**    
[`@mionkit/http`](../2.http-servers/1.node-js.md) uses node's native `IncomingMessage` and `ServerResponse` while [`@mionkit/serverless`](../3.serverless/1.aws-lambda.md) uses `APIGatewayEvent` and `APIGatewayProxyResult`. But routes and hooks will alway receive a standard MionRequest & MionResponse.


## How data is sent and received

When making a route call the `URL.path` is the route's id and is used for the route lookup. The http request body is a json object where keys are the route or hooks `ids` and the values are `Arrays` containing the parameters for each respective route or hook. This is done so multiple hooks or routes can be called in a single http request.

The http response follows the same format were the body is a json object where the keys are the `ids` and the values are the responses from the remote methods.

::code-group
::code-block{label="Example" preview}
| Request Path | Request Body                      | Response Body                          |
| ------------ | --------------------------------- | -------------------------------------- |
| `/sayHello`  | `{"sayHello": ["John"] }`         | `{"sayHello": "Hello John."}`          |
| `/greetings` | `{"greetings": ["Adan", "Eve"] }` | `{"greetings": "Hello Adan and Eve."}` |

The reason for this format is to be able to send/receive data for multiple hooks and routes in a single http request, independently of which route has been called.
::

::code-block{label="routes"}
<!-- embedme ../../../../packages/router/examples/req-respn.routes.ts -->
```ts
import {RouteDef, Routes} from '@mionkit/router';

// Defining a route as simple function
const sayHello = (ctx, name: string): string => {
    return `Hello ${name}.`;
}; // Satisfies Route

// Using a Route Definition object
const sayHello2 = {
    enableSerialization: false,
    enableValidation: false,
    // route handler
    route(ctx, name1: string, name2: string): string {
        return `Hello ${name1} and ${name2}.`;
    },
} satisfies RouteDef;

const routes = {
    sayHello,
    sayHello2,
} satisfies Routes;

```
::
::

::alert{type="info"}
Please note all this logic of correctly formatting request & response data is handled transparently by the [Client](../4.client.md).
::


:spacer

## Type Reference

::mion-type{id="request"}
#name
MionRequest
#code

mion's Request object, does not depends on the underlay native request.

<!-- embedme ../../../../packages/router/src/types/context.ts#L31-L40 -->
```ts
export interface MionRequest {
    /** parsed headers */
    readonly headers: Readonly<MionHeaders>;
    /** json encoded request body. */
    readonly rawBody: string;
    /** parsed request body */
    readonly body: Readonly<AnyObject>;
    /** All errors thrown during the call are stored here so they can bee logged or handler by a some error handler hook */
    readonly internalErrors: Readonly<RpcError[]>;
}
```
::


::mion-type{id="response"}
#name
MionResponse
#code

mion's Response object, does not depends on the underlay native response.

<!-- embedme ../../../../packages/router/src/types/context.ts#L43-L54 -->
```ts
export interface MionResponse {
    /** response http status code */
    readonly statusCode: number;
    /** response headers */
    readonly headers: Readonly<MionHeaders>;
    /** json encoded response body, filled only after all routes/hook has ben finalized. */
    readonly rawBody: string;
    /** the router response data, body should not be modified manually so marked as Read Only */
    readonly body: Readonly<RemoteMethodResponses>;
    /** response errors: empty if there were no errors during execution */
    readonly hasErrors: boolean;
}
```
::


::mion-type{id="mion-header"}
#name
MionHeaders
#code

mion's headers object, does not depends on the underlay native response.

Similar to the Headers [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Headers){target="_blank"}

<!-- embedme ../../../../packages/router/src/types/context.ts#L60-L69 -->
```ts
export interface MionHeaders {
    append(name: string, value: HeaderValue): void;
    delete(name: string): void;
    set(name: string, value: HeaderValue): void;
    get(name: string): HeaderValue | undefined | null;
    has(name: string): boolean;
    entries(): IterableIterator<[string, HeaderValue]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<HeaderValue>;
}
```
::


